<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威中文论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_4.htm">上一页</a>
<a class="pagelink" href="paper_6.htm">下一页</a>
<a class="pagelink" href="paper_6.htm">尾页</a>
页码：5/6页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">128</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>模式一：</span><span class='green'>触发器-参数模式，它是最普遍的模式，里面包含了名词加动词的语法结构，比如说 A phosphorylate B，</span><span class='green'>A phosphorylate B in C， B phosphorylated by A in C等等， phosphorylate是触发器， A， B， C都是参数。</span><span class='green'>根据语法规则，在描述蛋白质磷酸化的句子中语法结构一般都是激酶磷酸化了蛋白质在某某位点上，所以在上述我们可以大概推出 A可能是激酶，</span><span class='green'>然后再结合 A的类型（第一个模块里面已经获取了短语 A的词语类型）加以判断，如果 A类型是蛋白质类型，</span><span class='green'>那么就认为 A就是一种激酶（激酶也是一种特殊的蛋白质）。</span><span class='green'>在语法结构 A phosphorylate B中，根据英语的语法我们可以大概退出 B可能是被修饰的蛋白质，</span><span class='green'>也可能是位点，那 B具体是啥，这样根据模块一种得出的短语 B的词语类型，</span><span class='green'>假如说 B是蛋白质类型，那么 B就是被修饰的蛋白质，如果 B是蛋白质上的附属物，</span><span class='green'>那么 B就是位点（位点是蛋白质上的一部分）。</span><span class='green'>由此可见在这个模块里不仅可以发现短语之间的关系，还能够确定短语究竟是属于被修饰的蛋白质，还是激酶，还是位点。</span><span class='green'>模式二：</span><span class='green'>扩展模式，由于英文语法的多样性，表示这三者之间的关系不仅仅只靠以上几种语法结构就能匹配的，于是又新增了很多扩展的模式来匹配，模式三：</span><span class='green'>链接关系模式，在英文语法中会出现这样的情况，A phosphorylate protein such as x，xxx，protein先行再前，其真正的主体是x，xxx，所以protein和x，xxx有着链接的关系。</span><span class='green'>这样的先行词和先行词后面紧跟定义的链接关系还有很多种，所以在这里必须要考虑这样一种情况。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">129</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.5.3 嵌入使用Rlims-p工具</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">130</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>打开Rlims-p工具的网址http:</span><span class='green'>// research. bioinformatics. udel. edu/ rlimsp，点击页面的 Web Service超链接，他给我们提供了一个网页服务编程接口，</span><a href='../sentence_detail/379.htm' target='right' class='red' >我们可以通过 Http请求中的 post方法并把待处理的文本数据转换成 post参数，发送至服务地址 http:</a><span class='green'>//annotation.dbi.udel.edu/text_mining/bioc/bioc.php 上，服务器就回处理并返回一个XML格式的文本文件，里面包含了处理之后得到的实体名称，和实体之间的关系。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">131</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.6 多线程处理文档优化</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">132</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>考虑到我们文档集中的文件数量非常庞大，如果在同一个线程里面处理这么庞大的文件的话将会非常耗时，所以我不得不采用多线程的方式来并发的处理文档集里面所有的文档。</span><a href='../sentence_detail/383.htm' target='right' class='orange' >JAVA语言特性也是支持多线程开发的，更方便的是JAVA库java.util.concurrent中提供了线程池的工具，方便我们管理和调度线程。</a><span class='green'>为了避免多个线程同时处理同一个文档，尽量让每个线程都独立，互斥的运行，我设计了两套解决方案，</span><span class='green'>第一种方案是在同一时候只允许一个线程去文档集里面取文档，并把文件标记为已读，取到要处理的文档之后各个线程该干嘛就干嘛，</span><a href='../sentence_detail/386.htm' target='right' class='orange' >互不影响，直到文档集全部处理完毕。</a><span class='green'>（PS :</span><span class='green'>取文档只是一个获取对文档的引用标识，耗时远远低于处理文档的时候，所以同一时刻只有一个线程获取文档的引用并不影响程序的效率）。</span><a href='../sentence_detail/389.htm' target='right' class='orange' > Java运用 synchronized关键字和同步锁的机制可以实现同一时刻只用一个线程在取文件，</a><a href='../sentence_detail/390.htm' target='right' class='orange' >线程在执行带有关键字 synchronized的方法的时候会检查一下同步锁有没有被释放，</a><span class='green'>没有释放就表示正有线程在运行这个方法，就会一直等待直到同步锁被释放再运行。</span><span class='green'>第二种方案是首先预先分配线程池的大小，然后再把文档分给各个线程去处理，每个线程要处理的文件的数量都保持差不多的水平。</span><span class='green'>比如说，我有一万个文档要处理，文档编号从1-10000，那么首先分配一个最大支持50个线程同时运行的线程池，</span><span class='green'>再给每个线程分配200个待处理文档，文档的序号要分段开来，线程1处理1-200的文档，</span><span class='green'>线程2处理201-400的文档，依次类推，直到所有的文档集都分配完成，这样一来每个线程都知道自己要处理哪一批文档，</span><span class='green'>不会发生越界的情况。</span><span class='green'>但是第二种方法的不好之处在于假如某个线程所处理的文档内容非常小，一下子就处理完毕了，</span><span class='green'>那么这个时候这么线程就结束了，它不会去为别的线程分担压力了，线程池里面就少了一个线程，</span><span class='green'>就不能时时刻刻发挥线程池处理的最大能力了，而第一种方案，线程池里面时时刻刻都能够保持最大的线程数量，</span><span class='green'>除非待处理的文档数量少于线程数量了。</span><span class='green'>形象地来说，第一种方案像一个非常团结的团队，团队中的每一个人做完了一个任务后就争着去抢下一个任务做，直到任务全部完成为止。</span><span class='green'>第二种方案像一个自私的团队，团队中的每一个人随机的领了相同数量的任务，任务做得快的人就早早地下班了，</span><span class='green'>不会帮别人分担，任务做得慢的人就加班加点完成任务，但是最终的效率是由最后一个完成任务的人决定的，</span><a href='../sentence_detail/404.htm' target='right' class='red' >所以从效率来说显然是第一种好过第二种，所以在程序设计的时候，我采用的是第一种方案，</a><a href='../sentence_detail/405.htm' target='right' class='orange' >图4-12展示了方案一的处理流程图。</a><span class='green'>Pubmed文献库中和磷酸化先关的文献有20多万篇，如果只用一个线程去处理的话，</span><span class='green'>再加上用 Rlims- p工具本身就非常耗时的网络请求的话，那么处理这20万篇的文献的耗时将会达几十天，</span><span class='green'>如果处理的文献数量达到几百几千万篇的时候，那么我相信一台电脑的计算能力就不太够用了，</span><a href='../sentence_detail/409.htm' target='right' class='orange' >可能就要用到分布式机制的才能够提高处理的效率。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">133</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-12</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">134</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.7 文档预处理和缓存机制</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">135</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-13</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">136</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在客户端发起的请求，服务端要处理一段时间后才会返回给用户，这个时候用户就需要等待了，文档数量如此庞大，</span><span class='green'>如果有很多个用户同时来请求的话，那服务器处理的时间就会变得很长，返回给用户的时间也就会变得很长，</span><span class='green'>为了解决此问题，提升程序的用户体验，我们要预先对所有的文档进行处理，并且把处理后文档的结果保存再缓存区里面，</span><span class='green'>然后每次用户请求的时候，服务端这边直接把缓存区里面的结果直接返回给用户，这样的话就减少了很多用户等待的时间，</span><a href='../sentence_detail/417.htm' target='right' class='orange' >图4-13展示了缓存机制的一个逻辑流程图。</a><span class='green'>第一步我们需要对文档进行预处理，预先找出文档里面的实体和关系，这一步也需要用到先前提到的多线程的处理方式来处理，</span><span class='green'>然后把这些结果通过文件的形式保存在文件系统里面，通过文件名来作其的键值 key，</span><span class='green'>文件内容则是 value。</span><span class='green'>在 JAVA里面把一个 java Object（文档处理结果）输出成一个文件，用到了序列化的机制，通过让这个 java object实现序列化，</span><span class='green'>然后通过 FileOutPut把它以字节流的方式输出，最后得到的文件就是我们的缓存文件。</span><span class='green'>有了缓存之后，用户请求发送过来之后，首先我们会根据用户发送过来想要处理的文档的 id来去缓存文件夹下面去找对应的缓存文件，</span><span class='green'>如果找到了就把这个结果返回给用户，如果没找到的话就按照正常的流程来处理文件，处理完成之后再把处理结果存进缓存文件夹，</span><span class='green'>这样一来，对于文档集新增的文档还没来得及做一次预处理，这个时候用户只需再第一次请求的时候进行等待，</span><a href='../sentence_detail/426.htm' target='right' class='orange' >之后的请求都可以从缓存直接获取不用等待了。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">137</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/427.htm' target='right' class='orange' >第五章 数据库设计和数据可视化</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">138</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.1数据库设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">139</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>从需求上来看，需求是要从给定的pubmed文献中挖掘出文本中的被修饰的蛋白质，激酶，和位点这三种实体，以及这三种实体之间的关系。</span><a href='../sentence_detail/430.htm' target='right' class='red' >由此我们可以归纳出数据库中表里的字段，表5-1给出了表中的字段以及字段的含义。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">140</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>表5-1</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">141</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Id自动增长的id，主键</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">142</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Pmidpubmed文献在文献检索系统中的id</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">143</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Titlepubmed文献的标题</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">144</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>TextPubmed文献的内容</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">145</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Substrate被修饰的蛋白质</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">146</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Kinase修饰蛋白质的激酶</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">147</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Position修饰蛋白质的位点</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">148</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Acid文中氨基酸实体</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">149</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>phosphorylation磷酸化的词语或短语</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">150</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Relation实体之间的磷酸化的关系</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">151</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>表中一共有十个字段，其中蛋白质，激酶，位点等这种实体的每个字段可能有多个实体短语，</span><span class='green'>所以我们规定这些短语之间用逗号隔开，另外同一个实体可能出现在不同的字段里面，例如实体 A在关系 R1里面充当了蛋白质的角色，</span><span class='green'>而在关系 R2里面充当了激酶的角色（激酶也是一种特殊的蛋白质），这样的话实体 A既出现在蛋白质字段里面，</span><span class='green'>也出现在激酶字段里面。</span><span class='green'>实体关系这个字段比较特殊，因为文献中可能包含多种关系，或者不包含关系，而每一个关系包含了五种类型的实体，</span><span class='green'>为了简单起见我们还是把这个关系保存在一个字段里面，而不是新建一个表专门用来存储关系，首先 relation字段在程序里面的数据结构是一个 List，</span><span class='green'>List中的每一个 element就是每一种不同的关系，关系 element的数据结构又是一个 map( key， value)，</span><span class='green'>key就是字段名， value就是识别出来的实体。</span><span class='green'>综合来说关系在程序中的数据结构就是List(Map)，在java程序中采用List中的toString成员方法可以把关系结构转换成一个字符串，再把这个字符串保存至数据库。</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_4.htm">上一页</a>
<a class="pagelink" href="paper_6.htm">下一页</a>
<a class="pagelink" href="paper_6.htm">尾页</a>
页码：5/6页
]
</div>

<br><br><br>
<div style="margin-left:25px">

<img src="../../images/guanwang.gif">
</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2015 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
